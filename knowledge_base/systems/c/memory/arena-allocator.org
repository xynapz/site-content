#+TITLE: Arena Allocators (Region-based Memory Management)
#+AUTHOR: Angel Dhakal
#+DATE: 2025-11-25
#+DESCRIPTION: My research and notes of my understanding of arena allocators
#+KEYWORDS: performance, optimization, c, systems
#+OPTIONS: ^:{} num:nil toc:5 html-postamble:nil
#+HTML_HEAD: <meta name="pub_date" content="2025-11-25" />
#+HTML_HEAD: <meta name="updated_date" content="2025-11-25" />
#+EXPORT_FILE_NAME: /home/angel/xynapz/angeld.me/src/content/writings/c/memory/arena-allocator.html

* Theory
An Arena (or Linear) allocator works by pre-allocating a large contiguous block of memory and utilizing a simple "bump pointer" to dole out sub-blocks.

** Complexity Analysis
Compared to a general-purpose allocator (like `malloc`), the complexity savings are massive:

| Operation    | Standard `malloc`         | Arena Allocator |
| Allocation   | $O(n)$ or $O(\log n)$ [fn:1] | $O(1)$          |
| Deallocation | $O(1)$ (usually)          | $O(1)$ (Batch)  |

[fn:1] Worst case for `malloc` involves traversing free lists to find a fit.

** Visual Model
The state of an arena is defined entirely by its starting address and the current offset pointer.

#+begin_src mermaid
graph LR
    A[Start Address] --> B[Allocated Object A]
    B --> C[Allocated Object B]
    C --> D[Allocated Object C]
    D --> E((Offset Pointer))
    E --> F[Free Memory...]
    F --> G[End Capacity]

    style E fill:#f9f,stroke:#333,stroke-width:2px
#+end_src


* Implementation
The implementation relies on simple pointer arithmetic. We cast the raw byte buffer to ~uintptr_t~ to handle address manipulation safely.

#+begin_src c
#include <stdint.h>
#include <stddef.h>
#include <assert.h>

typedef struct {
    unsigned char *buffer;
    size_t length;
    size_t offset;
} Arena;

// Returns a pointer to the start of the new block
void* arena_alloc(Arena *a, size_t size) {
    // Check for overflow
    if (a->offset + size > a->length) {
        return NULL;
    }

    void *ptr = &a->buffer[a->offset];
    a->offset += size;

    // Note: This implementation assumes size is already aligned.
    // See [[./data-alignment.org][Data Alignment]] for padding logic.
    return ptr;
}

// Resetting is instantaneous
void arena_reset(Arena *a) {
    a->offset = 0;
}
#+end_src

* Why this matters
In his 2022 talk "Data-Oriented Design," Mike Acton argues that `malloc` is a code smell in tight loops. By using an arena, we ensure that objects allocated together stay together in the CPU cache lines, significantly reducing TLB misses.

* References
- Hanson, D. R. (1996). *C Interfaces and Implementations*.
- Ginger Bill. "Memory Allocation Strategies."
