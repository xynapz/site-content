#+TITLE: Bash Mastery Documentation & Logs
#+AUTHOR: Angel Dhakal
#+DATE: 2025-12-07
#+DESCRIPTION: Documentation, Log, References, Resource for Bash Mastery
#+KEYWORDS: bash, mastery, documentation, technical-docs, linux, linux-docs, shell
#+OPTIONS: ^:{} num:nil toc:5 html-postamble:nil
#+HTML_HEAD: <meta name="pub_date" content="2025-12-07" />
#+HTML_HEAD: <meta name="updated_date" content="2025-12-07" />
#+EXPORT_FILE_NAME: /home/angel/xynapz/angeld.me/src/content/writings/linux/bash-mastery-documentation-and-logs.html

* Bash Mastery Documentation & Logs
I am writing this post from arch post installation environment, where I dont have any desktop environment setup, I am documenting this process of writing a bash script to automate my post-install steps of my arch-linux system.

** About Bash
Bash is a scripting language or a command interpreter developed for unix-like systems like linux. It was created by Brian Fox in 1989, and named It *Bash (Bourne Again Shell)* indicating its a born anew shell scripting language that was meant to replace its predecessor, Bourne Shell AKA *sh*.

** My History and Usecases
I knew of the concept of automating batch of repetitive tasks using scripting in linux environments from way back from my college days, where I would often distro-hop, try new tools, naively participate in linux community formus in sites like reddits, arch-wiki, ubuntu-stackexchage, etc. I know a very basic level of scripting right now as well, but I would not say that I am a master at it to solve any freakin problem with scripting. But I have used linux for almost 7 years, 8 in May 2026, and just knowing the basics in 7 years is shameful, This post will first, test my skill boundary in bash and rework on it and learn new things my writing a script to setup the post-arch installation, desktop environment for myself, using my already existing [[https://github.com/xynapz/dotfiles][dotfiles repository]] in github.

** Bash Invocation & Startup

Invocation is just another name for how bash starts up, think of it like how a computer system start (normal mode, safe mode, recovery mode), bash also does a similar thing to boot itself up, during when a user login to system or starts a shell in already authenticated environment. This is the invocation of bash.

Startup files are the initial script files that the bash executes when it starts.

*** Two methods of invocation
**** Interactive & Non-Interactive Invocations
*Interactive*: This is the way which most users of linux are very familiar way of running some bash commands. When you open a terminal, it waits for you to type a command in, after a symbol, mostly after *$* symbol, it then executes the command and returns the output to the terminal. This method of invocation handles history of commands, and the process/job/task itself.

*Non-Interactive*: A non-interact invocation is the method of bash invocation in which, a script file is run instead of a command. All scripts use non-interactive shell for invocation and they cannot do any other task in between execution of that script.
**** Login & Non-Login Interactive Invocation
*Login Shell*: This is the shell, a user gets access to after authenticating with their username and password during the session start. This is the stage where bash sets up the entire environment, including PATH and other environment variables.

*Non-Login Shell*: After you are logged in to your desktop, you open a new terminal, or open a new tab inside of an already opened terminal, or when typing bash inside of an existing shell, the shell that starts is the non-login shell.

*** Scenario 1: Invocation with Interactive Login Shell.
When we first login to a system, the bash shell reads some startup scripts in order, they are as follows:
1. */etc/profile* which contains system-wide environment variables and configurations.
2. Then it looks for one of these files in order:
   - ~/.bash_profile
   - ~/.bash_login
   - ~/.profile
3. And upon logout *~/.bash_logout* is read.

*Now a question arised in my mind*
*how about the .bashrc file?*
Well it seems *.bashrc* file is not read by the login shell. This file is read by the non-login shells, explained below in [[*Scenario 2: Invocation with Interactive Non-Login Shell.][Scenario 2]].
*** Scenario 2: Invocation with Interactive Non-Login Shell.
When we open a terminal by clicking on the terminal icon from our desktop, the shell that opens is a interactive non-login shell. Or, if we open a new tab in already opened terminal, or.These are few examples of interactive non-login shell.
The files the bash shell reads when entering the interactive non-login shell is, intense music, more-intensified music, yes, its *~/.bashrc*
*** Scenario 3: Invoking in Non-Interactive Shell.
All script files that run are in a non-interactive shell. In this scenario, the script is run in a clean slate, to make sure that the script runs predictably.
*** Scenario 4: Invocation with the sh command.
If you create a symbolic link of bash and name it as sh, and run a script using thew new named sh link, it runs as a POSIX standard *sh* shelll instead. In that case it will read these files in order:
1. /etc/profile
2. ~/.bash_profile
*** Scenario 5: Invocation in POSIX Mode.
In this mode, bash is forced to adhere to the POSIX standard to execute the scripts. We can enable posix mode by running *set -o posix* or running bash with *--posix* option, will also force the standard, the last approach is, by setting the environment variable *POSIXLY_CORRECT*, which also forces the POSIX standard for the script we are trying to run. The advantage of this is that our script will be able to run in most system that adhere to strict POSIX standard.
*** Scenatio 6: Invoked Remotely.
When we invoke a script in a remote shell, the file read by the remote shell is the *~/.bashrc* file.

** Logging
While writing a shell script, in my opinion, it is very important to see real-time log of what commands are executing?, what procedure are being executed?, what issue has arrised? these details are very crucial for observing, analysing and debugging the script in case if the script fails or crashes. Using colorful text appropriately is a best practice that will make it easier to read info from a black screen.

To log data from a script to a standard output like a terminal screen, we can just do echo to print stuff on the screen.
#+begin_src bash
  echo "Message to log to the screen."
#+end_src

#+RESULTS:
: Message to log to the screen.

** Immediate Termination Upon Error
In most cases, when we are using a script to automate a task, we want the script to terminate its execution immediately if there is any sort of issue, bug, or any kind of bad signal received. The reason for this immediate exit on error is, a script is a series of instruction, that have to executed in order, and there is point in executing the next instruction if an error has occured while executing the current instruction.

** Variables
As any other programming language, a bash is just a named identifier for a data object. There are two types of variables
in bash, *global* variables and *local* variables.

*** Global Variable
A global variable is a variable that is available in all the shells in a system. It is also called environment variables. They are named *ALL_CAPS* to denote they are global or environment variables. They can be set in shell configuration files which makes it available to all available shells. In a shell, we can view all global variables using *env* or *printenv* commands.

#+begin_src bash
  env
#+end_src

#+RESULTS:
| SHELL=/usr/bin/zsh                                                                                   |
| HYPRLAND_CMD=Hyprland                                                                                 |
| XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session1                                              |
| XDG_BACKEND=wayland                                                                                   |
| DESKTOP_SESSION=hyprland                                                                              |
| XDG_SEAT=seat0                                                                                        |
| PWD=/home/angel/dotfiles/scripts/setup                                                               |
| XDG_SESSION_DESKTOP=Hyprland                                                                           |
| LOGNAME=angel                                                                                        |
| XDG_SESSION_TYPE=wayland                                                                               |
| _=/usr/bin/env                                                                                       |
| MOTD_SHOWN=pam                                                                                        |
| HOME=/home/angel                                                                                     |
| LANG=en_US.UTF-8                                                                                      |
| _JAVA_AWT_WM_NONREPARENTING=1                                                                           |
| XDG_CURRENT_DESKTOP=Hyprland                                                                           |
| WAYLAND_DISPLAY=wayland-1                                                                             |
| XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0                                                    |
| XDG_SESSION_CLASS=user                                                                                 |
| TERM=dumb                                                                                            |
| USER=angel                                                                                           |
| HYPRLAND_INSTANCE_SIGNATURE=386376400119dd46a767c9f8c8791fd22c7b6e61_1765136001_108445813                |
| DISPLAY=:1                                                                                           |
| SHLVL=1                                                                                              |
| MOZ_ENABLE_WAYLAND=1                                                                                   |
| XDG_VTNR=1                                                                                            |
| XDG_SESSION_ID=2                                                                                       |
| XDG_RUNTIME_DIR=/run/user/1000                                                                         |
| DEBUGINFOD_URLS=https://debuginfod.archlinux.org                                                      |
| PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl |
| DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus                                                   |
| MAIL=/var/spool/mail/angel                                                                           |
| OLDPWD=/home/angel                                                                                   |

*** Local Variables
Local Variables are variables that are available in the current shell only. In some conventions local variables are all capitalized and in some conventions they are not. So its up to the user to follow a style for naming their own local variables, but being consistent here is the key.

*** Types of Variables
The variables in bash has four main types, they are:
- Integer Variables
- String Variables
- Constant Variables
- Array Variables

*** Creating Variables
Variables in bash are case-sensitive, naming a variable is simple in bash, you can give any name, but giving a variable a name that starts with a digit is an error.

#+begin_src bash
  1name="Angel"
  echo "$1name"
#+end_src

#+RESULTS:
: name
: bash: line 1: 1name=Angel: command not found

**** Space around equals (=) sign
Giving a space around equal sign will result in an error. Examples

#+begin_src bash
  name = "Angel"
  echo "$name"
#+end_src

#+RESULTS:
: bash: line 1: name: command not found

#+begin_src bash
  name="Angel"
  echo "$name"
#+end_src

#+RESULTS:
: Angel

Above in the the first example, if you look closely, there is space around *=* while assigning *Angel* to name, this is not allowed while creating a variable in bash, the second code block which doesn't have any leading or trailing space around *=* sign, is valid syntax to create a variable in bash.

**** Exporting a Variable
A variable that we create is only available in that shell, if we want a variable to exists for all of its child-shell also called subshells, child-process, etc. then we can export a variable using the *export* keyword, what that does, is, it basically exports that variables for all of its child-process to access it, even modify it, but the modified variables only exists within that child-shell or its children shells, but not in the parent shell, it still has its original reference.

#+begin_src bash
  export name='Angel'
#+end_src

In above example, the name variable will be available to the child shell that this command is run on.

*** Reserved Keywords
Since bash is a extension of sh, all the reserved keywords of sh are also reserved in bash, plus there are a few more reserved keywords that bash has, so naming our variables, that is not a reserved keyword is a compulsory. Some examples are, *HOME*, *PATH*, *PS1*, *SHELL*, etc.

** Quoting, Expansion and Aliases
*** Quoting Characters
In bash a lot of characters have special meaning to them, syntactly and logically. Quoting is a mechanism of removing
those sepcial meaning of those characters and lay them as plain ASCII characters.

**** Escape Character
Escape character is used to remove the special meaning from a single character. To acheive this a non-quoted backslash, *\*, is used as the escape character in bash.

#+begin_src bash
  #without escape char
  name="Angel"
  echo "$name"

  #with escape char
  echo "\$name"
#+end_src

#+RESULTS:
| Angel |
| $name |

**** Single Quotes
Everything withing the single quotes is taken literally, this is also called strong quoting. Every special characters inside the single quote loses its meaning these include *$*, *\*, *\"* etc. A single quote character *'* also cannot be inside single quotes.

One example:
#+begin_src bash
  echo '$date'
#+end_src

#+RESULTS:
: $date

**** Double Quotes
Double quoting a variable or text is known as weak quoting. It quotes the literal value of all characters except, backslash *\*, dollar sign *$* and backticks *``*.

#+begin_src bash
  echo "Angel'$\"\\"
#+end_src

#+RESULTS:

*** Shell Expansion
When bash executes a script, it splits the commands into tokens (operands, operators, etc), some of these tokens might not be resolved, one famous example is *~* symbol, it doesnt have any meaning in the linux-kernel, its the bash shell that resolves *~* to */home/uname/* everywhere it encounters the symbol. And there are eight types of symbol exansion in bash.

- **Brace Expansion**
- **Tilde Expansion**
- **Parameter & Variable Expansion**
- **Command Substitution**
- **Arithmetic Expansion**
- **Process Substitution**
- **Word Splitting**
- **Filename Expansion**
- **Aliase Expansion**

You can get more information about them at [[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_04.html][TLDP-Bash-Beginners-Guide]].

** Regular Expressions
Regular Expression pvovides a language for performing pattern matching, data extraction and heavy text processing. They are not just in bash but everywhere in computer science, where text manipulation and processing involves like, text editors, find-and-replace, a lot of technologies use regular expressions to find a pattern of text in a large pool of text object.

In bash utilities like sed, grep, etc use regular expression for processing text. SO understanding them is a must if my goal is to master bash.

*** Mechnish and Syntax
In bash, the use of *=[[]]=*  double bracket is used whenever we want to do some pattern matching using regex (regular-expression), alongside the *=~* operator, the reason for double brackets unlike single braces is because double brackets directly performs the operation by treating the contents inside of brackets as pure regex and not performing any kind of [[*Shell Expansion][Shell Expansion]], that would be an invalid regex syntax.

#+begin_src bash
my_string="cat"
if [[ $my_string =~ c.t ]]; then
    # commands
    echo "Hello"
else
    echo "World"
fi
#+end_src

#+RESULTS:
: Hello

Here, the dot(*.*) between c, t, is a regular-expression metacharacter (a character that has a special meaning in regex) that means match any single character. Some other metacharacters are given below on a table.



** The GNU sed stream editor
/coming soon/
** The GNU awk programming language
/coming soon/
** Conditional Statements
The conditional statements provides a mechanism for executing commands based on some condition, just like in other general programming languages, they follow the same structure, *if / else if / else* blocks to acheive conditional execution of instructions. Bash also has case statements, similar to switch statements in other general purpose programming languages. Lets quickly look at each of them. There's a lot of examples and problems at the end of this post to put into practice.

*** if-elif-else
They are our standard building blocks for conditional exection, the syntax for them is a little different from languages like c/c++, but still they are as much intuitive.

#+begin_src bash
if [[ $age -gt 18 ]]; then
    echo "Adult"
elif [[ $age -eq 18 ]]; then
    echo "New Adult"
else
    echo "Minor"
fi
#+end_src

Conditional expression we used here is very simple, but in bash, there a different ways to compare strings, numbers, files, dirs, commands, etc. Lets look at them.

**** Strings and Number Comparison
**String Comparison**
| *Operator* | *Description* |
| ==       | Equals      |
| !=       | Not-Equals  |
| -z       | Empty       |
| -n       | Not-Empty   |

**Number Comparison**
| *Operator* | *Description*  |
| -eq      | Equals       |
| -ne      | Not-Equals   |
| -gt      | Greater-Than |
| -lt      | Less-Than    |

**** Primary Expressions

** Looping and Repetition
/coming soon/
** Functions
In bash, functions exists, like other programming languages, they are used for reusing repetitive piece of logic multiple times without repeating too much. Function usually takes arguments executes some instructions or commands in bash and return back. The syntax for a function is simple, the name of the function followd by a pair of parenthesis, and the function's body enclosed inside a pair of curly braces.

#+begin_src bash
  log () {
      echo "Static Message"
  }

  log_file() {
      echo "$1"
  }

  log
  log_file "test.sh"
#+end_src

#+RESULTS:
| Static  | Message |
| test.sh |         |

** Little about signals

* References

